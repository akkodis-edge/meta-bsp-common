#!/bin/sh

die() {
	echo "booterror: $1"
	reboot -n -f
}

export PATH=/sbin:/bin:/usr/sbin:/usr/bin

# Core setup
mkdir -p /sys /proc /dev || die "Failed creating core directories"
mount -t sysfs none /sys || die "Failed mounting /sys"
mount -t proc none /proc || die "Failed mounting /proc"
mount -t devtmpfs none /dev || die "Failed mounting /dev/"
modprobe squashfs || die "Failed loading driver squashfs"
modprobe overlay || die "Failed loading driver overlay"
modprobe dm-verity || die "Failed loading driver dm-verity"
modprobe dm-crypt || die "Failed loading driver dm-crypt"

# Parse kernel cmdline - disable globbing (-f)
set -f
for arg in $(cat /proc/cmdline); do
	case "$arg" in
	root=*)
		karg_root="${arg#root=}"
		echo "Found cmdline \"root=$karg_root\""
		;;
	esac
done
set +f

# Find root device
echo "Finding root device"
if [ "x$karg_root" != "x" ]; then
	# Kernel commandline root=
	case "$karg_root" in
	PARTUUID=*)
		blkid_options="--match-token"
		blkid_match="$karg_root"
		;;
	PARTLABEL=*)
		blkid_options="--match-token"
		blkid_match="$karg_root"
		;;
	/dev/*)
		blkid_options=""
		blkid_match="$karg_root"
		;;
	esac
elif [ -d /sys/firmware/efi ]; then
	# Platform UEFI
	echo "UEFI boot. Finding ESP"
	mount -t efivarfs none /sys/firmware/efi/efivars || die "Failed mounting /sys/firmware/efi/efivars"
	# Skip 4 first bytes containing efi header and convert utf-16 to utf-8 by dropping all null-characters.
	# UUID should not contain non-utf-8 characters.
	espuuid="$(cat /sys/firmware/efi/efivars/LoaderDevicePartUUID-4a67b082-0a4c-41cf-b6c7-440b29bb8c4f | tail -c +5 | tr -d '\000' | awk '{print tolower($0)}')" \
		|| die "Failed reading LoaderDevicePartUUID"
	blkid_options="--match-token"
	blkid_match="PARTUUID=$espuuid"
elif [ "x@FALLBACK_MATCH@" != "x" ]; then
	# Optional fallback
	blkid_options="@FALLBACK_OPTIONS@"
	blkid_match="@FALLBACK_MATCH@"
	echo "Using fallback: $blkid_options $blkid_match"
else
	die "No supported root device available"
fi

# Find device
echo "Waiting for root device: \"$blkid_match\""
while true; do
	srcdev=$(blkid $blkid_options "$blkid_match" -o device)
	if [ $? != 0 -a $? != 2 ]; then
		# No match and error returned
		die "Failed looking for root device"
	fi
	[ "x$srcdev" != "x" ] && break
	sleep 0.1
done
echo "Found: $srcdev"

# Mount device
mkdir -p /rootfs.dev || die "Failed creating mount directories"
mount -o ro "$srcdev" /rootfs.dev || die "Failed mounting $srcdev"

# Enable dm-verity mapping for rootfs integrity
roothash_0="$(container-util @ROOTFS_PUBLIC_KEY@ --open rootfs.0 /rootfs.dev/boot/rootfs.squashfs)" || die "Failed enabling dm-verity"

# Mount squash
mkdir -p /rootfs.0 || die "Failed creating squash mountpoint"
mount -t squashfs -o ro /dev/mapper/rootfs.0 /rootfs.0 || die "Failed mounting squashfs"

# Overlay an additional read-only squashfs image on top of rootfs if
# file /rootfs.dev/boot/rootfs.squashfs.1 is available.
# On error the additional rootfs is silently dropped.
if [ -f /rootfs.dev/boot/rootfs.squashfs.1 ]; then
	roothash_1="$(container-util @ROOTFS_PUBLIC_KEY@ --open rootfs.1 /rootfs.dev/boot/rootfs.squashfs.1)"
	if [ $? -eq 0 ]; then
		echo "Found squashfs.1"
		mkdir -p /rootfs.1 || die "Failed creating squashfs.1 mountpoint"
		if mount -t squashfs -o ro /dev/mapper/rootfs.1 /rootfs.1; then
			# Verify the additional image has the roothash of rootfs.0 available
			# in /rootfs.1/boot/roothash.compatible
			if [ "$roothash_0" = "$(cat /rootfs.1/boot/roothash.compatible)" ]; then
				echo "Verified squashfs.1"
				lower_extra="/rootfs.1:"
			else
				umount /rootfs.1 || die "Failed unmounting squasfs.1"
				rmdir /rootfs.1 || die "Failed removing squashfs.1 mountpoint"
				veritysetup close rootfs.1 || die "Failed closing squashfs.1 verity"
				roothash_1=""
			fi
		else
			rmdir /rootfs.1 || die "Failed removing squashfs.1 mountpoint"
			veritysetup close rootfs.1 || die "Failed closing squashfs.1 verity"
		fi
	fi
fi

# By default the upper/workdir are stored in ram (tmpfs).
# Presence of file /rootfs.dev/boot/rootfs.persistent will move the writeable
# directory from ram to boot device, making changes persistent.
mkdir -p /rootfs.rw || die "Failed creating overlay rw directory"
echo "Attempting persistent root type: $(rootfsctl --type)"
# link kernel keyring, see issue here:
# https://github.com/systemd/systemd/issues/5522
keyctl link @u @us || echo "Failed linking kernel keyring"
if ! rootfsctl --open; then
	echo "No persistent root -- mount volatile"
	mount -t tmpfs tmpfs /rootfs.rw || die "Failed mounting volatile rw area"
fi

# Mount overlay
mkdir -p /rootfs.rw/upper /rootfs.rw/work || die "Failed populating rw directory"
mkdir -p /rootfs || die "Failed creating overlay target directory"
mount -t overlay overlay -o lowerdir=${lower_extra}/rootfs.0,upperdir=/rootfs.rw/upper,workdir=/rootfs.rw/work /rootfs \
	|| die "Failed mounting root overlay"

# Change root
mkdir -p /rootfs /rootfs/rootfs.0 /rootfs/rootfs.rw /rootfs/rootfs.dev || die "Failed creating root directories"
mount --move /rootfs.0 /rootfs/rootfs.0 || die "Failed moving rootfs.0"
mount --move /rootfs.rw /rootfs/rootfs.rw || die "Failed moving rootfs.rw"
mount --move /rootfs.dev /rootfs/rootfs.dev || die "Failed moving rootfs.dev"
if [ -d /rootfs.1 ]; then
	mkdir -p /rootfs/rootfs.1 || die "Failed creating root directories"
	mount --move /rootfs.1 /rootfs/rootfs.1 || die "Failed moving rootfs.1"
fi

cd /rootfs || die "Failed moving to new rootfs"
exec switch_root . /sbin/init "$@" || die "Failed switch_root"

die "Should not be here"
