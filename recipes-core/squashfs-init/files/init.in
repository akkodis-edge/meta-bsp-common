#!/bin/sh

die() {
	echo "booterror: $1"
	reboot -n -f
}

export PATH=/sbin:/bin:/usr/sbin:/usr/bin

srcmount="/rootfs.dev"
srcrootimg="${srcmount}/boot/rootfs.squashfs"
newroot="/rootfs"

# Core setup
mkdir -p /sys /proc /dev || die "Failed creating core directories"
mount -t sysfs none /sys || die "Failed mounting /sys"
mount -t proc none /proc || die "Failed mounting /proc"
mount -t devtmpfs none /dev || die "Failed mounting /dev/"
modprobe squashfs || die "Failed loading driver squashfs"
modprobe overlay || die "Failed loading driver overlay"

# Parse kernel cmdline
cat /proc/cmdline | xargs -n1 | while read -r arg; do
	case "$arg" in
	root=*)
		karg_root="${arg#root=}"
		echo "Found cmdline \"root=$karg_root\""
		;;
	esac
done

# Find root device
echo "Finding root device"
if [ "x$karg_root" != "x" ]; then
	# Kernel commandline root=
	case "$karg_root" in
	PARTUUID=*)
		blkid_options="--match-token"
		blkid_match="$karg_root"
		;;
	PARTLABEL=*)
		blkid_options="--match-token"
		blkid_match="$karg_root"
		;;
	/dev/*)
		blkid_options=""
		blkid_match="$karg_root"
		;;
	esac
elif [ -d /sys/firmware/efi ]; then
	# Platform UEFI
	echo "UEFI boot. Finding ESP"
	mount -t efivarfs none /sys/firmware/efi/efivars || die "Failed mounting /sys/firmware/efi/efivars"
	# Skip 4 first bytes containing efi header and convert utf-16 to utf-8 by dropping all null-characters.
	# UUID should not contain non-utf-8 characters.
	espuuid="$(tail -c +5 /sys/firmware/efi/efivars/LoaderDevicePartUUID-4a67b082-0a4c-41cf-b6c7-440b29bb8c4f | tr -d '\000' | awk '{print tolower($0)}')" || die "Failed reading LoaderDevicePartUUID"
	blkid_options="--match-token"
	blkid_match="PARTUUID=$espuuid"
elif [ "x@FALLBACK_MATCH@" != "x" ]; then
	# Optional fallback
	blkid_options="@FALLBACK_OPTIONS@"
	blkid_match="@FALLBACK_MATCH@"
	echo "Using fallback: $blkid_options $blkid_match"
else
	die "No supported root device available"
fi

# Find and mount device
echo "Waiting for root device: \"$blkid_match\""
while true; do
	srcdev=$(blkid $blkid_options "$blkid_match" -o device)
	if [ $? != 0 -a $? != 2 ]; then
		# No match and error returned
		die "Failed looking for root device"
	fi
	[ "x$srcdev" != "x" ] && break
	sleep 0.1
done
echo "Found: $srcdev"

mkdir -p "$srcmount" || die "Failed creating mount directories"
mount -o ro "$srcdev" "$srcmount" || die "Failed mounting $srcdev"

# Overlay setup for root
mkdir -p "$newroot" /rootfs.ro /rootfs.rw || die "Failed creating overlay directories"
mount -t tmpfs tmpfs /rootfs.rw || die "Failed mounting /rootfs.rw"
mkdir /rootfs.rw/work /rootfs.rw/upper || die "Failed creating /rootfs.rw directories"
mount -t squashfs -o ro "$srcrootimg" /rootfs.ro || die "Failed mounting squashfs"
mount -t overlay overlay -o lowerdir=/rootfs.ro,upperdir=/rootfs.rw/upper,workdir=/rootfs.rw/work "$newroot" \
	|| die "Failed mounting root overlay"

# Change root
mkdir -p "${newroot}/rootfs.ro" "${newroot}/rootfs.rw" "${newroot}/rootfs.dev" || die "Failed creating root directories"
mount --move /rootfs.ro "${newroot}/rootfs.ro" || die "Failed moving rootfs.ro"
mount --move /rootfs.rw "${newroot}/rootfs.rw" || die "Failed moving rootfs.rw"
mount --move "$srcmount" "${newroot}/rootfs.dev" || die "Failed moving rootfs.dev"
cd "$newroot" || die "Failed moving to new rootfs"
exec switch_root . /sbin/init "$@" || die "Failed switch_root"

die "Should not be here"
