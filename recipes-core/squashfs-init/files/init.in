#!/bin/sh

die() {
	echo "booterror: $1"
	reboot -n -f
}

export PATH=/sbin:/bin:/usr/sbin:/usr/bin

# Core setup
mkdir -p /sys /proc /dev || die "Failed creating core directories"
mount -t sysfs none /sys || die "Failed mounting /sys"
mount -t proc none /proc || die "Failed mounting /proc"
mount -t devtmpfs none /dev || die "Failed mounting /dev/"
modprobe squashfs || die "Failed loading driver squashfs"
modprobe overlay || die "Failed loading driver overlay"

# Parse kernel cmdline - disable globbing (-f)
set -f
for arg in $(cat /proc/cmdline); do
	case "$arg" in
	root=*)
		karg_root="${arg#root=}"
		echo "Found cmdline \"root=$karg_root\""
		;;
	esac
done
set +f

# Find root device
echo "Finding root device"
if [ "x$karg_root" != "x" ]; then
	# Kernel commandline root=
	case "$karg_root" in
	PARTUUID=*)
		blkid_options="--match-token"
		blkid_match="$karg_root"
		;;
	PARTLABEL=*)
		blkid_options="--match-token"
		blkid_match="$karg_root"
		;;
	/dev/*)
		blkid_options=""
		blkid_match="$karg_root"
		;;
	esac
elif [ -d /sys/firmware/efi ]; then
	# Platform UEFI
	echo "UEFI boot. Finding ESP"
	mount -t efivarfs none /sys/firmware/efi/efivars || die "Failed mounting /sys/firmware/efi/efivars"
	# Skip 4 first bytes containing efi header and convert utf-16 to utf-8 by dropping all null-characters.
	# UUID should not contain non-utf-8 characters.
	espuuid="$(tail -c +5 /sys/firmware/efi/efivars/LoaderDevicePartUUID-4a67b082-0a4c-41cf-b6c7-440b29bb8c4f | tr -d '\000' | awk '{print tolower($0)}')" \
		|| die "Failed reading LoaderDevicePartUUID"
	blkid_options="--match-token"
	blkid_match="PARTUUID=$espuuid"
elif [ "x@FALLBACK_MATCH@" != "x" ]; then
	# Optional fallback
	blkid_options="@FALLBACK_OPTIONS@"
	blkid_match="@FALLBACK_MATCH@"
	echo "Using fallback: $blkid_options $blkid_match"
else
	die "No supported root device available"
fi

# Find device
echo "Waiting for root device: \"$blkid_match\""
while true; do
	srcdev=$(blkid $blkid_options "$blkid_match" -o device)
	if [ $? != 0 -a $? != 2 ]; then
		# No match and error returned
		die "Failed looking for root device"
	fi
	[ "x$srcdev" != "x" ] && break
	sleep 0.1
done
echo "Found: $srcdev"

# Mount device
mkdir -p /rootfs.dev || die "Failed creating mount directories"
mount -o ro "$srcdev" /rootfs.dev || die "Failed mounting $srcdev"

# Mount squash
mkdir -p /rootfs.ro || die "Failed creating squash mountpoint"
mount -t squashfs -o ro /rootfs.dev/boot/rootfs.squashfs /rootfs.ro || die "Failed mounting squashfs"

# Mount overlay
mkdir -p /rootfs.rw || die "Failed creating overlay rw directory"
# By default the upper/workdir are stored in ram (tmpfs).
# Presence of file /rootfs.dev/boot/rootfs.persistent will move the writeable
# directory from ram to boot device, making changes persistent.
if [ -f /rootfs.dev/boot/rootfs.persistent ]; then
	mount -o remount,rw /rootfs.dev || die "Failed remounting boot device rw"
	mkdir -p /rootfs.dev/boot/rootfs.rw || die "Failed creating persistent rw area"
	mount --bind /rootfs.dev/boot/rootfs.rw /rootfs.rw || die "Failed bind mounting rw directory to boot device"
else
	mount -t tmpfs tmpfs /rootfs.rw || die "Failed mounting volatile rw area"
fi
mkdir -p /rootfs.rw/upper /rootfs.rw/work || die "Failed populating rw directory"
mkdir -p /rootfs || die "Failed creating overlay target directory"
mount -t overlay overlay -o lowerdir=/rootfs.ro,upperdir=/rootfs.rw/upper,workdir=/rootfs.rw/work /rootfs \
	|| die "Failed mounting root overlay"

# Change root
mkdir -p /rootfs /rootfs/rootfs.ro /rootfs/rootfs.rw /rootfs/rootfs.dev || die "Failed creating root directories"
mount --move /rootfs.ro /rootfs/rootfs.ro || die "Failed moving rootfs.ro"
mount --move /rootfs.rw /rootfs/rootfs.rw || die "Failed moving rootfs.rw"
mount --move /rootfs.dev /rootfs/rootfs.dev || die "Failed moving rootfs.dev"
cd /rootfs || die "Failed moving to new rootfs"
exec switch_root . /sbin/init "$@" || die "Failed switch_root"

die "Should not be here"
